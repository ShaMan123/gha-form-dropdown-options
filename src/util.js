import fs from 'fs';
import { DEFAULT_SCHEMA, types, dump, load } from 'js-yaml';

// configure null to be stringified to ''
types.null.defaultStyle = 'empty';
const schema = DEFAULT_SCHEMA;

const RE = '${...}';

export function parseYAML(input) {
	return load(input, { schema });
}

export function stringifyYAML(data) {
	return dump(data, { schema });
}

export function readYAMLFile(file) {
	return parseYAML(fs.readFileSync(file).toString());
}

export function writeYAMLFile(file, data) {
	fs.writeFileSync(file, stringifyYAML(data));
}

function isStaticDropdownEmptyOptions(dropdown) {
	const {
		attributes: { options }
	} = dropdown;
	if (
		!options ||
		!options.length ||
		(Array.isArray(options) && options.every((option) => !option))
	) {
		return true;
	} else {
		return false;
	}
}

function isStaticDropdownIdPrefix(dropdown, inputs) {
	const { id } = dropdown;
	const startWithStatic =
		id.startWith(inputs.prefixStatic) && inputs.prefixStatic;
	const startWithNotStatic = id.startWith(inputs.prefix) && inputs.prefix;
	console.log(startWithStatic, startWithNotStatic);
	if (startWithStatic && !startWithNotStatic) {
		return true;
	} else if (!startWithStatic && startWithNotStatic) {
		return false;
	} else {
		return null;
	}
}

function isStaticDropdown(dropdown, strategy) {
	switch (strategy.strategy) {
		case 'id-prefix':
			const isStatic = isStaticDropdownIdPrefix(dropdown, strategy);
			if (isStatic === null) {
				throw new Error(
					`Failed to determine if dropdown '${dropdown.id}' is static using the prefixes [${inputs.prefixStatic}, ${inputs.prefix}]`
				);
			}
			return isStatic;
		case 'empty-options':
			return isStaticDropdownEmptyOptions(dropdown);
		case 'mixed':
			return (
				isStaticDropdownIdPrefix(dropdown, strategy) ||
				isStaticDropdownEmptyOptions(dropdown)
			);
		default:
			throw new Error(`Unknown strategy '${strategy}'`);
	}
}

function readYAML(file, template, strategy) {
	if (template && fs.existsSync(file)) {
		// avoid overriding existing options by prefilling template with actual form data
		// avoid prefilling static dropdown (with populated options) in case the template has been updated
		const templateContent = readYAMLFile(template);
		const content = readYAMLFile(file);
		templateContent.body.forEach((entry, index) => {
			if (entry.type !== 'dropdown') return;
			if (!isStaticDropdown(entry, strategy)) {
				templateContent.body[index].attributes.options =
					content.body[index].attributes.options;
			}
		});
		return templateContent;
	}
	return readYAMLFile(template || file);
}

export function writeYAML({
	form,
	template,
	dropdown: dropdownId,
	attributes,
	strategy
}) {
	const content = readYAML(form, template, strategy);
	const found = content.body.find(
		(entry) => entry.id === dropdownId && entry.type === 'dropdown'
	);
	if (!found) {
		throw new Error(
			`dropdown ${dropdownId} not found.\n${content.body.filter(
				(entry) => entry.type === 'dropdown'
			)}`
		);
	}
	const compatAttributes = {};
	for (const key in attributes) {
		let value = attributes[key];
		const templateValue = found.attributes[key];
		if (!value) continue;
		if (template) {
			if (typeof templateValue === 'string') {
				value = value.replace(RE, templateValue);
			} else if (Array.isArray(value) && Array.isArray(templateValue)) {
				const out = [];
				value.forEach((entry) =>
					entry === RE ? out.push(...templateValue) : out.push(entry)
				);
				value = out;
			}
		}
		compatAttributes[key] = value;
	}
	found.attributes = { ...found.attributes, ...compatAttributes };
	let out = stringifyYAML(content);
	if (template) {
		const HEADER = `
#
# This file was generated by the action ShaMan123/gha-form-dropdown-options using the template '${template}' 
# Update this file by editing '${template}'
#
`;
		out = `${HEADER}\n\n${out}`;
	}
	fs.writeFileSync(form, out);
	return content;
}
